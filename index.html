<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Tetris + Dr. Mario Game</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function TetrisMarioGame() {
          const canvasRef = useRef(null);
          const [gameStarted, setGameStarted] = useState(false);
          const [gameOver, setGameOver] = useState(false);
          const [score, setScore] = useState(0);
          const [level, setLevel] = useState(1);
          const [combo, setCombo] = useState(0);

          const COLS = 10;
          const ROWS = 20;
          const BLOCK_SIZE = 25;

          const SHAPES = {
            I: [[1,1,1,1]],
            O: [[1,1],[1,1]],
            T: [[0,1,0],[1,1,1]],
            S: [[0,1,1],[1,1,0]],
            Z: [[1,1,0],[0,1,1]],
            J: [[1,0,0],[1,1,1]],
            L: [[0,0,1],[1,1,1]]
          };

          const COLORS = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];

          const gameState = useRef({
            board: Array(ROWS).fill(null).map(() => Array(COLS).fill(null)),
            currentPiece: null,
            currentX: 0,
            currentY: 0,
            pieceColors: null,
            dropCounter: 0,
            dropInterval: 1000,
            lastTime: 0,
            virusCount: 0,
            animationId: null
          });

          const createPiece = () => {
            const pieces = Object.keys(SHAPES);
            const piece = pieces[Math.floor(Math.random() * pieces.length)];
            const shape = SHAPES[piece];
            
            const colors = shape.map(row => 
              row.map(cell => cell ? COLORS[Math.floor(Math.random() * COLORS.length)] : null)
            );
            
            return { shape, colors };
          };

          const rotate = (matrix) => {
            return matrix[0].map((_, i) => 
              matrix.map(row => row[i]).reverse()
            );
          };

          const checkCollision = (state, piece, x, y) => {
            for (let row = 0; row < piece.length; row++) {
              for (let col = 0; col < piece[row].length; col++) {
                if (piece[row][col]) {
                  const newY = y + row;
                  const newX = x + col;
                  
                  if (newX < 0 || newX >= COLS || newY >= ROWS) {
                    return true;
                  }
                  if (newY >= 0 && state.board[newY][newX]) {
                    return true;
                  }
                }
              }
            }
            return false;
          };

          const mergePiece = (state) => {
            const piece = state.currentPiece;
            const colors = state.pieceColors;
            
            for (let row = 0; row < piece.length; row++) {
              for (let col = 0; col < piece[row].length; col++) {
                if (piece[row][col]) {
                  const y = state.currentY + row;
                  const x = state.currentX + col;
                  if (y >= 0) {
                    state.board[y][x] = colors[row][col];
                  }
                }
              }
            }
          };

          const findMatches = (state) => {
            const matches = new Set();
            
            for (let row = 0; row < ROWS; row++) {
              let count = 1;
              let color = state.board[row][0];
              
              for (let col = 1; col < COLS; col++) {
                if (state.board[row][col] === color && color !== null) {
                  count++;
                  if (count >= 4) {
                    for (let i = 0; i < count; i++) {
                      matches.add(`${row}-${col - i}`);
                    }
                  }
                } else {
                  count = 1;
                  color = state.board[row][col];
                }
              }
            }
            
            for (let col = 0; col < COLS; col++) {
              let count = 1;
              let color = state.board[0][col];
              
              for (let row = 1; row < ROWS; row++) {
                if (state.board[row][col] === color && color !== null) {
                  count++;
                  if (count >= 4) {
                    for (let i = 0; i < count; i++) {
                      matches.add(`${row - i}-${col}`);
                    }
                  }
                } else {
                  count = 1;
                  color = state.board[row][col];
                }
              }
            }
            
            return matches;
          };

          const clearMatches = (state) => {
            const matches = findMatches(state);
            
            if (matches.size > 0) {
              matches.forEach(coord => {
                const [row, col] = coord.split('-').map(Number);
                state.board[row][col] = null;
              });
              
              applyGravity(state);
              
              const points = matches.size * 50 * (combo + 1);
              setScore(s => s + points);
              setCombo(c => c + 1);
              
              setTimeout(() => {
                const newMatches = findMatches(state);
                if (newMatches.size > 0) {
                  clearMatches(state);
                } else {
                  setCombo(0);
                }
              }, 100);
              
              return true;
            }
            
            setCombo(0);
            return false;
          };

          const applyGravity = (state) => {
            for (let col = 0; col < COLS; col++) {
              let writeRow = ROWS - 1;
              
              for (let row = ROWS - 1; row >= 0; row--) {
                if (state.board[row][col] !== null) {
                  if (row !== writeRow) {
                    state.board[writeRow][col] = state.board[row][col];
                    state.board[row][col] = null;
                  }
                  writeRow--;
                }
              }
            }
          };

          const clearFullLines = (state) => {
            let linesCleared = 0;
            
            for (let row = ROWS - 1; row >= 0; row--) {
              if (state.board[row].every(cell => cell !== null)) {
                state.board.splice(row, 1);
                state.board.unshift(Array(COLS).fill(null));
                linesCleared++;
                setScore(s => s + 500 * level);
                row++;
              }
            }
            
            return linesCleared;
          };

          const spawnPiece = (state) => {
            const piece = createPiece();
            state.currentPiece = piece.shape;
            state.pieceColors = piece.colors;
            
            state.currentX = Math.floor(COLS / 2) - Math.floor(state.currentPiece[0].length / 2);
            state.currentY = 0;
            
            if (checkCollision(state, state.currentPiece, state.currentX, state.currentY)) {
              setGameOver(true);
              return false;
            }
            return true;
          };

          const drop = (state) => {
            state.currentY++;
            if (checkCollision(state, state.currentPiece, state.currentX, state.currentY)) {
              state.currentY--;
              mergePiece(state);
              
              const hasMatches = clearMatches(state);
              clearFullLines(state);
              
              spawnPiece(state);
            }
          };

          const moveLeft = () => {
            const state = gameState.current;
            if (!state.currentPiece || gameOver) return;
            
            state.currentX--;
            if (checkCollision(state, state.currentPiece, state.currentX, state.currentY)) {
              state.currentX++;
            }
          };

          const moveRight = () => {
            const state = gameState.current;
            if (!state.currentPiece || gameOver) return;
            
            state.currentX++;
            if (checkCollision(state, state.currentPiece, state.currentX, state.currentY)) {
              state.currentX--;
            }
          };

          const hardDrop = () => {
            const state = gameState.current;
            if (!state.currentPiece || gameOver) return;
            
            while (!checkCollision(state, state.currentPiece, state.currentX, state.currentY + 1)) {
              state.currentY++;
              setScore(s => s + 2);
            }
            drop(state);
          };

          const rotatePiece = () => {
            const state = gameState.current;
            if (!state.currentPiece || gameOver) return;
            
            const rotated = rotate(state.currentPiece);
            const rotatedColors = rotate(state.pieceColors);
            
            if (!checkCollision(state, rotated, state.currentX, state.currentY)) {
              state.currentPiece = rotated;
              state.pieceColors = rotatedColors;
            } else {
              if (!checkCollision(state, rotated, state.currentX - 1, state.currentY)) {
                state.currentPiece = rotated;
                state.pieceColors = rotatedColors;
                state.currentX--;
              } else if (!checkCollision(state, rotated, state.currentX + 1, state.currentY)) {
                state.currentPiece = rotated;
                state.pieceColors = rotatedColors;
                state.currentX++;
              }
            }
          };

          const spawnViruses = (state, count) => {
            for (let i = 0; i < count; i++) {
              let placed = false;
              let attempts = 0;
              
              while (!placed && attempts < 50) {
                const row = Math.floor(ROWS * 0.7) + Math.floor(Math.random() * (ROWS * 0.3));
                const col = Math.floor(Math.random() * COLS);
                
                if (state.board[row][col] === null) {
                  state.board[row][col] = COLORS[Math.floor(Math.random() * COLORS.length)];
                  placed = true;
                  state.virusCount++;
                }
                attempts++;
              }
            }
          };

          useEffect(() => {
            if (!gameStarted || gameOver) return;

            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            const state = gameState.current;

            canvas.width = COLS * BLOCK_SIZE;
            canvas.height = ROWS * BLOCK_SIZE;

            // Scale canvas to fit small screens like Apple Watch
            const maxW = window.innerWidth - 10;
            const maxH = window.innerHeight - 80;
            const scaleX = maxW / (COLS * BLOCK_SIZE);
            const scaleY = maxH / (ROWS * BLOCK_SIZE);
            const scale = Math.min(scaleX, scaleY, 1);
            canvas.style.width = (COLS * BLOCK_SIZE * scale) + 'px';
            canvas.style.height = (ROWS * BLOCK_SIZE * scale) + 'px';

            spawnViruses(state, 5 + level * 2);
            spawnPiece(state);
            state.dropInterval = Math.max(100, 800 - (level - 1) * 80);

            const drawBlock = (x, y, color) => {
              ctx.fillStyle = color;
              ctx.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
              
              ctx.strokeStyle = '#000';
              ctx.lineWidth = 2;
              ctx.strokeRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
              
              ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
              ctx.fillRect(x * BLOCK_SIZE + 4, y * BLOCK_SIZE + 4, BLOCK_SIZE - 8, (BLOCK_SIZE - 8) / 3);
            };

            const gameLoop = (timestamp) => {
              const deltaTime = timestamp - state.lastTime;
              state.lastTime = timestamp;
              state.dropCounter += deltaTime;

              if (state.dropCounter > state.dropInterval) {
                drop(state);
                state.dropCounter = 0;
              }

              ctx.fillStyle = '#000';
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              ctx.strokeStyle = '#222';
              ctx.lineWidth = 1;
              for (let i = 0; i <= COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * BLOCK_SIZE, 0);
                ctx.lineTo(i * BLOCK_SIZE, canvas.height);
                ctx.stroke();
              }
              for (let i = 0; i <= ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * BLOCK_SIZE);
                ctx.lineTo(canvas.width, i * BLOCK_SIZE);
                ctx.stroke();
              }

              const matches = findMatches(state);

              for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                  if (state.board[row][col]) {
                    const isMatch = matches.has(`${row}-${col}`);
                    
                    if (isMatch) {
                      const flash = Math.sin(timestamp / 100) * 0.5 + 0.5;
                      ctx.globalAlpha = 0.5 + flash * 0.5;
                    }
                    
                    drawBlock(col, row, state.board[row][col]);
                    ctx.globalAlpha = 1;
                  }
                }
              }

              if (state.currentPiece) {
                let ghostY = state.currentY;
                while (!checkCollision(state, state.currentPiece, state.currentX, ghostY + 1)) {
                  ghostY++;
                }
                
                for (let row = 0; row < state.currentPiece.length; row++) {
                  for (let col = 0; col < state.currentPiece[row].length; col++) {
                    if (state.currentPiece[row][col]) {
                      ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                      ctx.fillRect(
                        (state.currentX + col) * BLOCK_SIZE + 2,
                        (ghostY + row) * BLOCK_SIZE + 2,
                        BLOCK_SIZE - 4,
                        BLOCK_SIZE - 4
                      );
                    }
                  }
                }
              }

              if (state.currentPiece && state.pieceColors) {
                for (let row = 0; row < state.currentPiece.length; row++) {
                  for (let col = 0; col < state.currentPiece[row].length; col++) {
                    if (state.currentPiece[row][col]) {
                      drawBlock(
                        state.currentX + col, 
                        state.currentY + row, 
                        state.pieceColors[row][col]
                      );
                    }
                  }
                }
              }

              if (combo > 0) {
                ctx.fillStyle = '#ff0';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(`${combo}x COMBO!`, canvas.width / 2, 30);
                ctx.fillText(`${combo}x COMBO!`, canvas.width / 2, 30);
              }

              if (!gameOver) {
                state.animationId = requestAnimationFrame(gameLoop);
              }
            };

            const handleKeyDown = (e) => {
              if (gameOver) return;
              
              switch(e.key) {
                case 'ArrowLeft':
                  e.preventDefault();
                  moveLeft();
                  break;
                case 'ArrowRight':
                  e.preventDefault();
                  moveRight();
                  break;
                case 'ArrowDown':
                  e.preventDefault();
                  drop(state);
                  setScore(s => s + 1);
                  break;
                case 'ArrowUp':
                case ' ':
                  e.preventDefault();
                  rotatePiece();
                  break;
              }
            };

            window.addEventListener('keydown', handleKeyDown);
            state.animationId = requestAnimationFrame(gameLoop);

            return () => {
              window.removeEventListener('keydown', handleKeyDown);
              if (state.animationId) {
                cancelAnimationFrame(state.animationId);
              }
            };
          }, [gameStarted, gameOver, level, combo]);

          const startGame = () => {
            setGameStarted(true);
            setGameOver(false);
            setScore(0);
            setLevel(1);
            setCombo(0);
            gameState.current = {
              board: Array(ROWS).fill(null).map(() => Array(COLS).fill(null)),
              currentPiece: null,
              currentX: 0,
              currentY: 0,
              pieceColors: null,
              dropCounter: 0,
              dropInterval: 800,
              lastTime: 0,
              virusCount: 0,
              animationId: null
            };
          };

          return (
            <div style={{display:'flex',flexDirection:'row',alignItems:'center',justifyContent:'center',minHeight:'100vh',background:'linear-gradient(to bottom, #312e81, #581c87, #831843)',padding:'2px',overflow:'hidden',boxSizing:'border-box',position:'fixed',width:'100%',height:'100%'}}>
              
              {!gameStarted && !gameOver && (
                <div style={{textAlign:'center',padding:'8px'}}>
                  <div style={{fontSize:'14px',fontWeight:'bold',color:'white',marginBottom:'4px'}}>üíä TETRIS+MARIO</div>
                  <button
                    onClick={startGame}
                    style={{background:'linear-gradient(to right, #3b82f6, #8b5cf6)',color:'white',fontWeight:'bold',padding:'8px 16px',borderRadius:'8px',fontSize:'14px',border:'none',cursor:'pointer',marginBottom:'8px'}}
                  >
                    ‚ñ∂ Start
                  </button>
                  <div style={{color:'#d1d5db',fontSize:'10px',lineHeight:'1.4'}}>
                    <p>Match 4+ same colors!</p>
                    <p>Clear lines for points!</p>
                  </div>
                </div>
              )}

              {gameStarted && (
                <>
                  <div style={{display:'flex',flexDirection:'column',alignItems:'center'}}>
                    {/* Compact score bar */}
                    <div style={{display:'flex',gap:'4px',background:'rgba(31,41,55,0.9)',borderRadius:'4px',padding:'1px 4px',marginBottom:'1px',fontSize:'7px',color:'white'}}>
                      <span>‚≠ê{score}</span>
                      <span>Lv{level}</span>
                      {combo > 0 && <span style={{color:'#fb923c'}}>x{combo}</span>}
                    </div>

                    {/* Game canvas - scales to fit watch */}
                    <canvas
                      ref={canvasRef}
                      style={{border:'2px solid #8b5cf6',borderRadius:'4px',background:'black',maxWidth:'calc(100vw - 135px)',maxHeight:'calc(100vh - 15px)'}}
                    />
                  </div>

                  {/* Fixed compact controls on the side */}
                  <div style={{display:'grid',gridTemplateColumns:'40px 40px 40px',gridTemplateRows:'40px 40px 40px',gap:'2px',marginLeft:'3px'}}>
                    <div></div>
                    <button onClick={rotatePiece} style={{background:'#7c3aed',color:'white',fontWeight:'bold',padding:'4px',borderRadius:'6px',fontSize:'12px',border:'none',cursor:'pointer'}}>üîÑ</button>
                    <div></div>
                    <button onClick={moveLeft} style={{background:'#2563eb',color:'white',fontWeight:'bold',padding:'4px',borderRadius:'6px',fontSize:'14px',border:'none',cursor:'pointer'}}>‚Üê</button>
                    <button onClick={hardDrop} style={{background:'#dc2626',color:'white',fontWeight:'bold',padding:'4px',borderRadius:'6px',fontSize:'12px',border:'none',cursor:'pointer'}}>‚¨á</button>
                    <button onClick={moveRight} style={{background:'#2563eb',color:'white',fontWeight:'bold',padding:'4px',borderRadius:'6px',fontSize:'14px',border:'none',cursor:'pointer'}}>‚Üí</button>
                  </div>
                </>
              )}

              {gameOver && (
                <div style={{position:'fixed',top:'50%',left:'50%',transform:'translate(-50%,-50%)',textAlign:'center',background:'rgba(0,0,0,0.95)',padding:'12px',borderRadius:'8px',border:'2px solid #dc2626',maxWidth:'90%'}}>
                  <div style={{fontSize:'14px',color:'#f87171',fontWeight:'bold',marginBottom:'4px'}}>üíÄ GAME OVER</div>
                  <div style={{fontSize:'12px',color:'white',marginBottom:'2px'}}>‚≠ê{score}</div>
                  <div style={{fontSize:'10px',color:'#fbbf24',marginBottom:'6px'}}>Lv{level}</div>
                  <button
                    onClick={startGame}
                    style={{background:'linear-gradient(to right, #3b82f6, #8b5cf6)',color:'white',fontWeight:'bold',padding:'5px 12px',borderRadius:'6px',fontSize:'11px',border:'none',cursor:'pointer'}}
                  >
                    Play Again
                  </button>
                </div>
              )}
            </div>
          );
        }

        // Render the game
        ReactDOM.render(<TetrisMarioGame />, document.getElementById('root'));
    </script>
</body>
</html>
