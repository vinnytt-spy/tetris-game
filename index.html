<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris + Dr. Mario Game</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        function TetrisMarioGame() {
          const canvasRef = useRef(null);
          const [gameStarted, setGameStarted] = useState(false);
          const [gameOver, setGameOver] = useState(false);
          const [score, setScore] = useState(0);
          const [level, setLevel] = useState(1);
          const [combo, setCombo] = useState(0);
          const COLS = 10;
          const ROWS = 20;
          const BLOCK_SIZE = 25;
          const SHAPES = {
            I: [[1,1,1,1]],
            O: [[1,1],[1,1]],
            T: [[0,1,0],[1,1,1]],
            S: [[0,1,1],[1,1,0]],
            Z: [[1,1,0],[0,1,1]],
            J: [[1,0,0],[1,1,1]],
            L: [[0,0,1],[1,1,1]]
          };
          const COLORS = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
          const gameState = useRef({
            board: Array(ROWS).fill(null).map(() => Array(COLS).fill(null)),
            currentPiece: null, currentX: 0, currentY: 0,
            pieceColors: null, dropCounter: 0, dropInterval: 1000,
            lastTime: 0, virusCount: 0, animationId: null
          });
          const createPiece = () => {
            const pieces = Object.keys(SHAPES);
            const piece = pieces[Math.floor(Math.random() * pieces.length)];
            const shape = SHAPES[piece];
            const colors = shape.map(row => row.map(cell => cell ? COLORS[Math.floor(Math.random() * COLORS.length)] : null));
            return { shape, colors };
          };
          const rotate = (matrix) => matrix[0].map((_, i) => matrix.map(row => row[i]).reverse());
          const checkCollision = (state, piece, x, y) => {
            for (let row = 0; row < piece.length; row++)
              for (let col = 0; col < piece[row].length; col++)
                if (piece[row][col]) {
                  const newY = y + row, newX = x + col;
                  if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
                  if (newY >= 0 && state.board[newY][newX]) return true;
                }
            return false;
          };
          const mergePiece = (state) => {
            for (let row = 0; row < state.currentPiece.length; row++)
              for (let col = 0; col < state.currentPiece[row].length; col++)
                if (state.currentPiece[row][col]) {
                  const y = state.currentY + row, x = state.currentX + col;
                  if (y >= 0) state.board[y][x] = state.pieceColors[row][col];
                }
          };
          const findMatches = (state) => {
            const matches = new Set();
            for (let row = 0; row < ROWS; row++) {
              let count = 1, color = state.board[row][0];
              for (let col = 1; col < COLS; col++) {
                if (state.board[row][col] === color && color !== null) {
                  count++;
                  if (count >= 4) for (let i = 0; i < count; i++) matches.add(`${row}-${col - i}`);
                } else { count = 1; color = state.board[row][col]; }
              }
            }
            for (let col = 0; col < COLS; col++) {
              let count = 1, color = state.board[0][col];
              for (let row = 1; row < ROWS; row++) {
                if (state.board[row][col] === color && color !== null) {
                  count++;
                  if (count >= 4) for (let i = 0; i < count; i++) matches.add(`${row - i}-${col}`);
                } else { count = 1; color = state.board[row][col]; }
              }
            }
            return matches;
          };
          const applyGravity = (state) => {
            for (let col = 0; col < COLS; col++) {
              let writeRow = ROWS - 1;
              for (let row = ROWS - 1; row >= 0; row--)
                if (state.board[row][col] !== null) {
                  if (row !== writeRow) { state.board[writeRow][col] = state.board[row][col]; state.board[row][col] = null; }
                  writeRow--;
                }
            }
          };
          const clearMatches = (state) => {
            const matches = findMatches(state);
            if (matches.size > 0) {
              matches.forEach(coord => { const [r, c] = coord.split('-').map(Number); state.board[r][c] = null; });
              applyGravity(state);
              setScore(s => s + matches.size * 50 * (combo + 1));
              setCombo(c => c + 1);
              setTimeout(() => { if (findMatches(state).size > 0) clearMatches(state); else setCombo(0); }, 100);
              return true;
            }
            setCombo(0); return false;
          };
          const clearFullLines = (state) => {
            for (let row = ROWS - 1; row >= 0; row--)
              if (state.board[row].every(cell => cell !== null)) {
                state.board.splice(row, 1); state.board.unshift(Array(COLS).fill(null));
                setScore(s => s + 500 * level); row++;
              }
          };
          const spawnPiece = (state) => {
            const piece = createPiece();
            state.currentPiece = piece.shape; state.pieceColors = piece.colors;
            state.currentX = Math.floor(COLS / 2) - Math.floor(state.currentPiece[0].length / 2);
            state.currentY = 0;
            if (checkCollision(state, state.currentPiece, state.currentX, state.currentY)) { setGameOver(true); return false; }
            return true;
          };
          const drop = (state) => {
            state.currentY++;
            if (checkCollision(state, state.currentPiece, state.currentX, state.currentY)) {
              state.currentY--; mergePiece(state); clearMatches(state); clearFullLines(state); spawnPiece(state);
            }
          };
          const moveLeft = () => { const s = gameState.current; s.currentX--; if (checkCollision(s, s.currentPiece, s.currentX, s.currentY)) s.currentX++; };
          const moveRight = () => { const s = gameState.current; s.currentX++; if (checkCollision(s, s.currentPiece, s.currentX, s.currentY)) s.currentX--; };
          const hardDrop = () => {
            const s = gameState.current;
            while (!checkCollision(s, s.currentPiece, s.currentX, s.currentY + 1)) { s.currentY++; setScore(sc => sc + 2); }
            drop(s);
          };
          const rotatePiece = () => {
            const s = gameState.current;
            const r = rotate(s.currentPiece), rc = rotate(s.pieceColors);
            if (!checkCollision(s, r, s.currentX, s.currentY)) { s.currentPiece = r; s.pieceColors = rc; }
            else if (!checkCollision(s, r, s.currentX - 1, s.currentY)) { s.currentPiece = r; s.pieceColors = rc; s.currentX--; }
            else if (!checkCollision(s, r, s.currentX + 1, s.currentY)) { s.currentPiece = r; s.pieceColors = rc; s.currentX++; }
          };
          const spawnViruses = (state, count) => {
            for (let i = 0; i < count; i++) {
              let placed = false, attempts = 0;
              while (!placed && attempts < 50) {
                const row = Math.floor(ROWS / 2) + Math.floor(Math.random() * (ROWS / 2 - 2));
                const col = Math.floor(Math.random() * COLS);
                if (state.board[row][col] === null) { state.board[row][col] = COLORS[Math.floor(Math.random() * COLORS.length)]; placed = true; }
                attempts++;
              }
            }
          };
          useEffect(() => {
            if (!gameStarted || gameOver) return;
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            const state = gameState.current;
            canvas.width = COLS * BLOCK_SIZE;
            canvas.height = ROWS * BLOCK_SIZE;
            spawnViruses(state, 15 + level * 3);
            spawnPiece(state);
            state.dropInterval = Math.max(100, 800 - (level - 1) * 80);
            const drawBlock = (x, y, color) => {
              ctx.fillStyle = color;
              ctx.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
              ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
              ctx.strokeRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
              ctx.fillStyle = 'rgba(255,255,255,0.4)';
              ctx.fillRect(x * BLOCK_SIZE + 4, y * BLOCK_SIZE + 4, BLOCK_SIZE - 8, (BLOCK_SIZE - 8) / 3);
            };
            const gameLoop = (timestamp) => {
              state.dropCounter += timestamp - state.lastTime;
              state.lastTime = timestamp;
              if (state.dropCounter > state.dropInterval) { drop(state); state.dropCounter = 0; }
              ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
              ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
              for (let i = 0; i <= COLS; i++) { ctx.beginPath(); ctx.moveTo(i * BLOCK_SIZE, 0); ctx.lineTo(i * BLOCK_SIZE, canvas.height); ctx.stroke(); }
              for (let i = 0; i <= ROWS; i++) { ctx.beginPath(); ctx.moveTo(0, i * BLOCK_SIZE); ctx.lineTo(canvas.width, i * BLOCK_SIZE); ctx.stroke(); }
              const matches = findMatches(state);
              for (let row = 0; row < ROWS; row++)
                for (let col = 0; col < COLS; col++)
                  if (state.board[row][col]) {
                    if (matches.has(`${row}-${col}`)) ctx.globalAlpha = 0.5 + Math.sin(timestamp / 100) * 0.5 * 0.5;
                    drawBlock(col, row, state.board[row][col]);
                    ctx.globalAlpha = 1;
                  }
              if (state.currentPiece) {
                let ghostY = state.currentY;
                while (!checkCollision(state, state.currentPiece, state.currentX, ghostY + 1)) ghostY++;
                for (let row = 0; row < state.currentPiece.length; row++)
                  for (let col = 0; col < state.currentPiece[row].length; col++)
                    if (state.currentPiece[row][col]) {
                      ctx.fillStyle = 'rgba(255,255,255,0.2)';
                      ctx.fillRect((state.currentX + col) * BLOCK_SIZE + 2, (ghostY + row) * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
                    }
                for (let row = 0; row < state.currentPiece.length; row++)
                  for (let col = 0; col < state.currentPiece[row].length; col++)
                    if (state.currentPiece[row][col]) drawBlock(state.currentX + col, state.currentY + row, state.pieceColors[row][col]);
              }
              if (combo > 0) {
                ctx.fillStyle = '#ff0'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center';
                ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
                ctx.strokeText(`${combo}x COMBO!`, canvas.width / 2, 30);
                ctx.fillText(`${combo}x COMBO!`, canvas.width / 2, 30);
              }
              if (!gameOver) state.animationId = requestAnimationFrame(gameLoop);
            };
            const handleKeyDown = (e) => {
              if (gameOver) return;
              if (e.key === 'ArrowLeft') { e.preventDefault(); moveLeft(); }
              else if (e.key === 'ArrowRight') { e.preventDefault(); moveRight(); }
              else if (e.key === 'ArrowDown') { e.preventDefault(); drop(state); setScore(s => s + 1); }
              else if (e.key === 'ArrowUp' || e.key === ' ') { e.preventDefault(); rotatePiece(); }
            };
            window.addEventListener('keydown', handleKeyDown);
            state.animationId = requestAnimationFrame(gameLoop);
            return () => { window.removeEventListener('keydown', handleKeyDown); if (state.animationId) cancelAnimationFrame(state.animationId); };
          }, [gameStarted, gameOver, level, combo]);
          const startGame = () => {
            setGameStarted(true); setGameOver(false); setScore(0); setLevel(1); setCombo(0);
            gameState.current = { board: Array(ROWS).fill(null).map(() => Array(COLS).fill(null)), currentPiece: null, currentX: 0, currentY: 0, pieceColors: null, dropCounter: 0, dropInterval: 800, lastTime: 0, virusCount: 0, animationId: null };
          };
          return (
            <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-b from-indigo-900 via-purple-900 to-pink-900 p-4">
              {!gameStarted && !gameOver && (
                <div className="text-center mb-8">
                  <h1 className="text-5xl font-bold text-white mb-2">üíä TETRIS + DR. MARIO</h1>
                  <p className="text-xl text-yellow-300 mb-4">Match 4+ colors in a row!</p>
                  <button onClick={startGame} className="bg-gradient-to-r from-blue-500 to-purple-500 text-white font-bold py-4 px-8 rounded-lg text-2xl shadow-lg">Start Game</button>
                  <div className="mt-6 text-gray-300 space-y-2">
                    <p>üéÆ Stack Tetris pieces with random colors</p>
                    <p>üåà Match 4+ same colors horizontally or vertically</p>
                    <p>üí• Clear full lines for bonus points!</p>
                    <p>üî• Build combos for massive scores!</p>
                  </div>
                </div>
              )}
              {gameStarted && (
                <div className="flex flex-col items-center">
                  <div className="bg-gray-800 bg-opacity-90 p-3 rounded-lg mb-3 flex gap-6 text-center">
                    <div><div className="text-yellow-400 text-sm font-bold">SCORE</div><div className="text-white text-2xl font-bold">{score}</div></div>
                    <div><div className="text-blue-400 text-sm font-bold">LEVEL</div><div className="text-white text-2xl font-bold">{level}</div></div>
                    {combo > 0 && <div><div className="text-orange-400 text-sm font-bold">COMBO</div><div className="text-orange-300 text-2xl font-bold">{combo}x</div></div>}
                  </div>
                  <canvas ref={canvasRef} className="border-4 border-purple-500 rounded-lg shadow-2xl bg-black" />
                  <div className="mt-4 grid grid-cols-3 gap-2 w-64">
                    <button onClick={rotatePiece} className="col-start-2 bg-purple-600 text-white font-bold py-4 px-6 rounded-lg text-xl">üîÑ</button>
                    <div></div>
                    <button onClick={moveLeft} className="bg-blue-600 text-white font-bold py-4 px-6 rounded-lg text-xl">‚Üê</button>
                    <button onClick={hardDrop} className="bg-red-500 text-white font-bold py-4 px-6 rounded-lg text-xl">‚¨á</button>
                    <button onClick={moveRight} className="bg-blue-600 text-white font-bold py-4 px-6 rounded-lg text-xl">‚Üí</button>
                  </div>
                </div>
              )}
              {gameOver && (
                <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center bg-black bg-opacity-95 p-8 rounded-lg border-4 border-red-500">
                  <h2 className="text-4xl text-red-400 mb-4 font-bold">GAME OVER!</h2>
                  <p className="text-3xl text-white mb-2">Score: {score}</p>
                  <p className="text-xl text-yellow-400 mb-6">Level: {level}</p>
                  <button onClick={startGame} className="bg-gradient-to-r from-blue-500 to-purple-500 text-white font-bold py-3 px-8 rounded-lg text-xl">Play Again</button>
                </div>
              )}
            </div>
          );
        }
        ReactDOM.render(<TetrisMarioGame />, document.getElementById('root'));
    </script>
</body>
</html>
