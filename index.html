<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris + Dr. Mario Game</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function TetrisMarioGame() {
          const canvasRef = useRef(null);
          const [gameStarted, setGameStarted] = useState(false);
          const [gameOver, setGameOver] = useState(false);
          const [score, setScore] = useState(0);
          const [level, setLevel] = useState(1);
          const [combo, setCombo] = useState(0);

          const COLS = 10;
          const ROWS = 20;
          const BLOCK_SIZE = 25;

          const SHAPES = {
            I: [[1,1,1,1]],
            O: [[1,1],[1,1]],
            T: [[0,1,0],[1,1,1]],
            S: [[0,1,1],[1,1,0]],
            Z: [[1,1,0],[0,1,1]],
            J: [[1,0,0],[1,1,1]],
            L: [[0,0,1],[1,1,1]]
          };

          const COLORS = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];

          const gameState = useRef({
            board: Array(ROWS).fill(null).map(() => Array(COLS).fill(null)),
            currentPiece: null,
            currentX: 0,
            currentY: 0,
            pieceColors: null,
            dropCounter: 0,
            dropInterval: 1000,
            lastTime: 0,
            virusCount: 0,
            animationId: null
          });

          const createPiece = () => {
            const pieces = Object.keys(SHAPES);
            const piece = pieces[Math.floor(Math.random() * pieces.length)];
            const shape = SHAPES[piece];
            
            const colors = shape.map(row => 
              row.map(cell => cell ? COLORS[Math.floor(Math.random() * COLORS.length)] : null)
            );
            
            return { shape, colors };
          };

          const rotate = (matrix) => {
            return matrix[0].map((_, i) => 
              matrix.map(row => row[i]).reverse()
            );
          };

          const checkCollision = (state, piece, x, y) => {
            for (let row = 0; row < piece.length; row++) {
              for (let col = 0; col < piece[row].length; col++) {
                if (piece[row][col]) {
                  const newY = y + row;
                  const newX = x + col;
                  
                  if (newX < 0 || newX >= COLS || newY >= ROWS) {
                    return true;
                  }
                  if (newY >= 0 && state.board[newY][newX]) {
                    return true;
                  }
                }
              }
            }
            return false;
          };

          const mergePiece = (state) => {
            const piece = state.currentPiece;
            const colors = state.pieceColors;
            
            for (let row = 0; row < piece.length; row++) {
              for (let col = 0; col < piece[row].length; col++) {
                if (piece[row][col]) {
                  const y = state.currentY + row;
                  const x = state.currentX + col;
                  if (y >= 0) {
                    state.board[y][x] = colors[row][col];
                  }
                }
              }
            }
          };

          const findMatches = (state) => {
            const matches = new Set();
            
            for (let row = 0; row < ROWS; row++) {
              let count = 1;
              let color = state.board[row][0];
              
              for (let col = 1; col < COLS; col++) {
                if (state.board[row][col] === color && color !== null) {
                  count++;
                  if (count >= 4) {
                    for (let i = 0; i < count; i++) {
                      matches.add(`${row}-${col - i}`);
                    }
                  }
                } else {
                  count = 1;
                  color = state.board[row][col];
                }
              }
            }
            
            for (let col = 0; col < COLS; col++) {
              let count = 1;
              let color = state.board[0][col];
              
              for (let row = 1; row < ROWS; row++) {
                if (state.board[row][col] === color && color !== null) {
                  count++;
                  if (count >= 4) {
                    for (let i = 0; i < count; i++) {
                      matches.add(`${row - i}-${col}`);
                    }
                  }
                } else {
                  count = 1;
                  color = state.board[row][col];
                }
              }
            }
            
            return matches;
          };

          const clearMatches = (state) => {
            const matches = findMatches(state);
            
            if (matches.size > 0) {
              matches.forEach(coord => {
                const [row, col] = coord.split('-').map(Number);
                state.board[row][col] = null;
              });
              
              applyGravity(state);
              
              const points = matches.size * 50 * (combo + 1);
              setScore(s => s + points);
              setCombo(c => c + 1);
              
              setTimeout(() => {
                const newMatches = findMatches(state);
                if (newMatches.size > 0) {
                  clearMatches(state);
                } else {
                  setCombo(0);
                }
              }, 100);
              
              return true;
            }
            
            setCombo(0);
            return false;
          };

          const applyGravity = (state) => {
            for (let col = 0; col < COLS; col++) {
              let writeRow = ROWS - 1;
              
              for (let row = ROWS - 1; row >= 0; row--) {
                if (state.board[row][col] !== null) {
                  if (row !== writeRow) {
                    state.board[writeRow][col] = state.board[row][col];
                    state.board[row][col] = null;
                  }
                  writeRow--;
                }
              }
            }
          };

          const clearFullLines = (state) => {
            let linesCleared = 0;
            
            for (let row = ROWS - 1; row >= 0; row--) {
              if (state.board[row].every(cell => cell !== null)) {
                state.board.splice(row, 1);
                state.board.unshift(Array(COLS).fill(null));
                linesCleared++;
                setScore(s => s + 500 * level);
                row++;
              }
            }
            
            return linesCleared;
          };

          const spawnPiece = (state) => {
            const piece = createPiece();
            state.currentPiece = piece.shape;
            state.pieceColors = piece.colors;
            
            state.currentX = Math.floor(COLS / 2) - Math.floor(state.currentPiece[0].length / 2);
            state.currentY = 0;
            
            if (checkCollision(state, state.currentPiece, state.currentX, state.currentY)) {
              setGameOver(true);
              return false;
            }
            return true;
          };

          const drop = (state) => {
            state.currentY++;
            if (checkCollision(state, state.currentPiece, state.currentX, state.currentY)) {
              state.currentY--;
              mergePiece(state);
              
              const hasMatches = clearMatches(state);
              clearFullLines(state);
              
              spawnPiece(state);
            }
          };

          const moveLeft = () => {
            const state = gameState.current;
            if (!state.currentPiece || gameOver) return;
            
            state.currentX--;
            if (checkCollision(state, state.currentPiece, state.currentX, state.currentY)) {
              state.currentX++;
            }
          };

          const moveRight = () => {
            const state = gameState.current;
            if (!state.currentPiece || gameOver) return;
            
            state.currentX++;
            if (checkCollision(state, state.currentPiece, state.currentX, state.currentY)) {
              state.currentX--;
            }
          };

          const hardDrop = () => {
            const state = gameState.current;
            if (!state.currentPiece || gameOver) return;
            
            while (!checkCollision(state, state.currentPiece, state.currentX, state.currentY + 1)) {
              state.currentY++;
              setScore(s => s + 2);
            }
            drop(state);
          };

          const rotatePiece = () => {
            const state = gameState.current;
            if (!state.currentPiece || gameOver) return;
            
            const rotated = rotate(state.currentPiece);
            const rotatedColors = rotate(state.pieceColors);
            
            if (!checkCollision(state, rotated, state.currentX, state.currentY)) {
              state.currentPiece = rotated;
              state.pieceColors = rotatedColors;
            } else {
              if (!checkCollision(state, rotated, state.currentX - 1, state.currentY)) {
                state.currentPiece = rotated;
                state.pieceColors = rotatedColors;
                state.currentX--;
              } else if (!checkCollision(state, rotated, state.currentX + 1, state.currentY)) {
                state.currentPiece = rotated;
                state.pieceColors = rotatedColors;
                state.currentX++;
              }
            }
          };

          const spawnViruses = (state, count) => {
            for (let i = 0; i < count; i++) {
              let placed = false;
              let attempts = 0;
              
              while (!placed && attempts < 50) {
                const row = Math.floor(ROWS * 0.7) + Math.floor(Math.random() * (ROWS * 0.3));
                const col = Math.floor(Math.random() * COLS);
                
                if (state.board[row][col] === null) {
                  state.board[row][col] = COLORS[Math.floor(Math.random() * COLORS.length)];
                  placed = true;
                  state.virusCount++;
                }
                attempts++;
              }
            }
          };

          useEffect(() => {
            if (!gameStarted || gameOver) return;

            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            const state = gameState.current;

            canvas.width = COLS * BLOCK_SIZE;
            canvas.height = ROWS * BLOCK_SIZE;

            spawnViruses(state, 5 + level * 2);
            spawnPiece(state);
            state.dropInterval = Math.max(100, 800 - (level - 1) * 80);

            const drawBlock = (x, y, color) => {
              ctx.fillStyle = color;
              ctx.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
              
              ctx.strokeStyle = '#000';
              ctx.lineWidth = 2;
              ctx.strokeRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
              
              ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
              ctx.fillRect(x * BLOCK_SIZE + 4, y * BLOCK_SIZE + 4, BLOCK_SIZE - 8, (BLOCK_SIZE - 8) / 3);
            };

            const gameLoop = (timestamp) => {
              const deltaTime = timestamp - state.lastTime;
              state.lastTime = timestamp;
              state.dropCounter += deltaTime;

              if (state.dropCounter > state.dropInterval) {
                drop(state);
                state.dropCounter = 0;
              }

              ctx.fillStyle = '#000';
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              ctx.strokeStyle = '#222';
              ctx.lineWidth = 1;
              for (let i = 0; i <= COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * BLOCK_SIZE, 0);
                ctx.lineTo(i * BLOCK_SIZE, canvas.height);
                ctx.stroke();
              }
              for (let i = 0; i <= ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * BLOCK_SIZE);
                ctx.lineTo(canvas.width, i * BLOCK_SIZE);
                ctx.stroke();
              }

              const matches = findMatches(state);

              for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                  if (state.board[row][col]) {
                    const isMatch = matches.has(`${row}-${col}`);
                    
                    if (isMatch) {
                      const flash = Math.sin(timestamp / 100) * 0.5 + 0.5;
                      ctx.globalAlpha = 0.5 + flash * 0.5;
                    }
                    
                    drawBlock(col, row, state.board[row][col]);
                    ctx.globalAlpha = 1;
                  }
                }
              }

              if (state.currentPiece) {
                let ghostY = state.currentY;
                while (!checkCollision(state, state.currentPiece, state.currentX, ghostY + 1)) {
                  ghostY++;
                }
                
                for (let row = 0; row < state.currentPiece.length; row++) {
                  for (let col = 0; col < state.currentPiece[row].length; col++) {
                    if (state.currentPiece[row][col]) {
                      ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                      ctx.fillRect(
                        (state.currentX + col) * BLOCK_SIZE + 2,
                        (ghostY + row) * BLOCK_SIZE + 2,
                        BLOCK_SIZE - 4,
                        BLOCK_SIZE - 4
                      );
                    }
                  }
                }
              }

              if (state.currentPiece && state.pieceColors) {
                for (let row = 0; row < state.currentPiece.length; row++) {
                  for (let col = 0; col < state.currentPiece[row].length; col++) {
                    if (state.currentPiece[row][col]) {
                      drawBlock(
                        state.currentX + col, 
                        state.currentY + row, 
                        state.pieceColors[row][col]
                      );
                    }
                  }
                }
              }

              if (combo > 0) {
                ctx.fillStyle = '#ff0';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(`${combo}x COMBO!`, canvas.width / 2, 30);
                ctx.fillText(`${combo}x COMBO!`, canvas.width / 2, 30);
              }

              if (!gameOver) {
                state.animationId = requestAnimationFrame(gameLoop);
              }
            };

            const handleKeyDown = (e) => {
              if (gameOver) return;
              
              switch(e.key) {
                case 'ArrowLeft':
                  e.preventDefault();
                  moveLeft();
                  break;
                case 'ArrowRight':
                  e.preventDefault();
                  moveRight();
                  break;
                case 'ArrowDown':
                  e.preventDefault();
                  drop(state);
                  setScore(s => s + 1);
                  break;
                case 'ArrowUp':
                case ' ':
                  e.preventDefault();
                  rotatePiece();
                  break;
              }
            };

            window.addEventListener('keydown', handleKeyDown);
            state.animationId = requestAnimationFrame(gameLoop);

            return () => {
              window.removeEventListener('keydown', handleKeyDown);
              if (state.animationId) {
                cancelAnimationFrame(state.animationId);
              }
            };
          }, [gameStarted, gameOver, level, combo]);

          const startGame = () => {
            setGameStarted(true);
            setGameOver(false);
            setScore(0);
            setLevel(1);
            setCombo(0);
            gameState.current = {
              board: Array(ROWS).fill(null).map(() => Array(COLS).fill(null)),
              currentPiece: null,
              currentX: 0,
              currentY: 0,
              pieceColors: null,
              dropCounter: 0,
              dropInterval: 800,
              lastTime: 0,
              virusCount: 0,
              animationId: null
            };
          };

          return (
            <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-b from-indigo-900 via-purple-900 to-pink-900 p-4">
              {!gameStarted && !gameOver && (
                <div className="text-center mb-8">
                  <h1 className="text-5xl font-bold text-white mb-2">üíä TETRIS + DR. MARIO</h1>
                  <p className="text-xl text-yellow-300 mb-4">Match 4+ colors in a row!</p>
                  <button
                    onClick={startGame}
                    className="bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-bold py-4 px-8 rounded-lg text-2xl shadow-lg active:scale-95 transition"
                  >
                    Start Game
                  </button>
                  <div className="mt-6 text-gray-300 space-y-2">
                    <p>üéÆ Stack Tetris pieces with random colors</p>
                    <p>üåà Match 4+ same colors horizontally or vertically</p>
                    <p>üí• Clear full lines for bonus points!</p>
                    <p>üî• Build combos for massive scores!</p>
                  </div>
                </div>
              )}

              {gameStarted && (
                <div className="flex flex-col items-center">
                  <div className="bg-gray-800 bg-opacity-90 p-3 rounded-lg mb-3 flex gap-6 text-center">
                    <div>
                      <div className="text-yellow-400 text-sm font-bold">SCORE</div>
                      <div className="text-white text-2xl font-bold">{score}</div>
                    </div>
                    <div>
                      <div className="text-blue-400 text-sm font-bold">LEVEL</div>
                      <div className="text-white text-2xl font-bold">{level}</div>
                    </div>
                    {combo > 0 && (
                      <div>
                        <div className="text-orange-400 text-sm font-bold">COMBO</div>
                        <div className="text-orange-300 text-2xl font-bold animate-pulse">{combo}x</div>
                      </div>
                    )}
                  </div>

                  <canvas
                    ref={canvasRef}
                    className="border-4 border-purple-500 rounded-lg shadow-2xl bg-black"
                  />

                  <div className="mt-4 grid grid-cols-3 gap-2 w-64">
                    <button
                      onClick={rotatePiece}
                      className="col-start-2 bg-purple-600 hover:bg-purple-700 active:bg-purple-800 text-white font-bold py-4 px-6 rounded-lg text-xl"
                    >
                      üîÑ
                    </button>
                    <div></div>
                    <button
                      onClick={moveLeft}
                      className="bg-blue-600 hover:bg-blue-700 active:bg-blue-800 text-white font-bold py-4 px-6 rounded-lg text-xl"
                    >
                      ‚Üê
                    </button>
                    <button
                      onClick={hardDrop}
                      className="bg-gradient-to-b from-red-500 to-pink-600 hover:from-red-600 hover:to-pink-700 active:from-red-700 active:to-pink-800 text-white font-bold py-4 px-6 rounded-lg text-xl"
                    >
                      ‚¨á
                    </button>
                    <button
                      onClick={moveRight}
                      className="bg-blue-600 hover:bg-blue-700 active:bg-blue-800 text-white font-bold py-4 px-6 rounded-lg text-xl"
                    >
                      ‚Üí
                    </button>
                  </div>

                  <div className="mt-3 text-center text-white text-sm bg-gray-800 bg-opacity-75 p-2 rounded">
                    Match 4+ blocks of the same color to clear them!
                  </div>
                </div>
              )}

              {gameOver && (
                <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center bg-black bg-opacity-95 p-8 rounded-lg border-4 border-gradient-to-r from-red-500 to-purple-500">
                  <h2 className="text-4xl text-transparent bg-clip-text bg-gradient-to-r from-red-400 to-purple-400 mb-4 font-bold">GAME OVER!</h2>
                  <p className="text-3xl text-white mb-2">Score: {score}</p>
                  <p className="text-xl text-yellow-400 mb-6">Level: {level}</p>
                  <button
                    onClick={startGame}
                    className="bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-bold py-3 px-8 rounded-lg text-xl active:scale-95 transition"
                  >
                    Play Again
                  </button>
                </div>
              )}
            </div>
          );
        }

        // Render the game
        ReactDOM.render(<TetrisMarioGame />, document.getElementById('root'));
    </script>
</body>
</html>
